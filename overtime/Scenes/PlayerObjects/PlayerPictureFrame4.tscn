[gd_scene load_steps=9 format=3 uid="uid://c6lh217nvquvj"]

[ext_resource type="Material" uid="uid://d0k4t5nkqe4td" path="res://Assets/Materials/PictureFrame4.tres" id="1_6bnvm"]
[ext_resource type="Material" uid="uid://cwo0dk0bsf5e1" path="res://Assets/Materials/PerfectOutline.tres" id="4_busgw"]
[ext_resource type="ArrayMesh" uid="uid://dvb4vdxujcrnh" path="res://Assets/Enviroments/Office/Models/PictureFrame_4.obj" id="4_nos2b"]

[sub_resource type="GDScript" id="GDScript_f5sxg"]
script/source = "extends Interactable

# Store original position and rotation
var original_position: Vector3
var original_rotation: Vector3
var original_scale: Vector3

# Tween for smooth animations
var tween: Tween
var debug_mesh: MeshInstance3D

# Export the mesh and material to ensure they match the original object
@export var target_mesh: Mesh
@export var target_material: Material
@export var target_scale: Vector3 = Vector3.ONE

# Adjustable parameters for the focus behavior
@export var focus_distance: float = 1.2  # Distance in front of camera
@export var vertical_offset: float = -0.7  # Vertical offset from camera height (negative = lower)
@export var rotation_intensity: float = 1.0  # How much to rotate (0 = no rotation, 1 = full rotation)
@export var scale_multiplier: float = 1.5  # How much to scale the object during focus

# Track if we're currently in an interaction
var is_in_interaction: bool = false
# New bool to track if we should stay in focus mode
var should_stay_in_focus: bool = false

# Rotation speed (radians per second)
@export var rotation_speed: float = 1.5

# Current rotation angle
var current_rotation: float = 0.0


# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	PlayerManager.PictureFrame4 = self
	# Store original transform
	original_position = global_position
	original_rotation = global_rotation  # Use global_rotation instead of rotation
	original_scale = scale
	
	# Create a debug mesh that looks like the original object
	_create_debug_mesh()

func _create_debug_mesh() -> void:
	# Remove any existing debug mesh
	for child in get_children():
		if child.name == \"DebugMesh\":
			child.queue_free()
	
	# Create a new debug mesh
	debug_mesh = MeshInstance3D.new()
	debug_mesh.name = \"DebugMesh\"
	
	# Use the exported mesh and material
	if target_mesh:
		debug_mesh.mesh = target_mesh
	else:
		# Fallback to searching for a mesh
		var found_mesh = _find_original_mesh()
		if found_mesh:
			debug_mesh.mesh = found_mesh.mesh
		else:
			# Final fallback to a box mesh
			debug_mesh.mesh = BoxMesh.new()
			debug_mesh.scale = Vector3(0.5, 0.5, 0.1)
	
	# Apply the material if provided
	if target_material:
		debug_mesh.material_override = target_material
	
	# Apply the scale if provided
	if target_scale != Vector3.ONE:
		debug_mesh.scale = target_scale
	
	# Hide the debug mesh initially
	debug_mesh.visible = false
	
	add_child(debug_mesh)

func _find_original_mesh() -> MeshInstance3D:
	# Search for a MeshInstance3D in children (including nested children)
	return _find_mesh_in_children(self)

func _find_mesh_in_children(node: Node) -> MeshInstance3D:
	# Check if this node is a MeshInstance3D
	if node is MeshInstance3D and node.name != \"DebugMesh\":
		return node
	
	# Recursively check children
	for child in node.get_children():
		var result = _find_mesh_in_children(child)
		if result:
			return result
	
	return null

func _on_interacted(body: Variant) -> void:
	PlayerManager.ExamingItem = self
	$\"../../PictureFrame4Fade\".play(\"PictureFrame4Fade\")
	# Prevent multiple simultaneous interactions
	if is_in_interaction:
		return
	
	PlayerManager.examining = true
	PlayerManager.player.CURSOR.visible = false
	is_in_interaction = true
	should_stay_in_focus = true
	
	# Get the player's camera
	var camera = PlayerManager.player.CAMERA
	if not camera:
		is_in_interaction = false
		should_stay_in_focus = false
		return
	
	# Calculate position directly in front of the camera
	var camera_transform = camera.global_transform
	var focus_offset = camera_transform.basis.z * -focus_distance  # Adjustable distance in front of camera
	var focus_position = camera_transform.origin + focus_offset
	
	# Adjust height with vertical offset
	focus_position.y = camera_transform.origin.y + vertical_offset
	
	# Set up the debug mesh at the original position
	debug_mesh.global_position = global_position
	debug_mesh.global_rotation = global_rotation  # Use global_rotation
	debug_mesh.scale = scale
	
	# Hide the original object immediately and show the debug mesh
	_hide_original_object()
	debug_mesh.visible = true
	
	# Disable collision during focus to avoid issues
	if has_node(\"CollisionShape3D\"):
		$CollisionShape3D.disabled = true
	
	# Create tween for animations on the debug mesh
	tween = create_tween()
	tween.set_parallel(true)
	
	# Animate debug mesh to focus position
	tween.tween_property(debug_mesh, \"global_position\", focus_position, 1.0).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_CUBIC)
	
	# Make debug mesh face the camera properly
	# Get camera's position and forward direction
	var camera_position = camera.global_position
	var camera_forward = -camera.global_transform.basis.z
	
	# Calculate the direction from focus position to camera
	var direction_to_camera = (camera_position - focus_position).normalized()
	
	# Create a basis that faces the camera
	var target_basis = Basis()
	target_basis.z = direction_to_camera  # Forward faces camera
	target_basis.y = Vector3.UP  # Keep upright
	target_basis.x = target_basis.y.cross(target_basis.z).normalized()  # Calculate right vector
	target_basis = target_basis.orthonormalized()  # Ensure valid rotation
	
	# Convert to rotation
	var target_rotation = target_basis.get_euler()
	
	# Rotate 90 degrees to the right (in radians)
	target_rotation.y -= PI/2
	current_rotation = target_rotation.y
	
	# Apply rotation intensity
	if rotation_intensity < 1.0:
		var current_rotation = debug_mesh.global_rotation
		target_rotation = current_rotation.lerp(target_rotation, rotation_intensity)
	
	tween.tween_property(debug_mesh, \"global_rotation\", target_rotation, 1.0).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_CUBIC)
	
	# Scale up the debug mesh with adjustable multiplier
	tween.tween_property(debug_mesh, \"scale\", original_scale * scale_multiplier, 1.0).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_CUBIC)
	
	if not PlayerManager.examed:
		PlayerManager.CharacterHintDialog(\"Can't wait to go back here!\",\"Press A or D to rotate object while examing\")
		PlayerManager.examed = true
	elif PlayerManager.DeskItems.size() == 3 and not PlayerManager.has_item(\"Car Keys\"):
		PlayerManager.CharacterHintDialog(\"Can't wait to go back here!\",\"I should grab my keys and get out of here\")
	else:
		PlayerManager.CharacterDialog(\"Can't wait to go back here!\")
	
	# Wait for the second signal (should_stay_in_focus becomes false)
	while should_stay_in_focus:
		await get_tree().create_timer(0.1).timeout
	
	# Return to original position
	await _return_to_original()
	
	is_in_interaction = false

# Function to end the focus mode
func end_focus() -> void:
	PlayerManager.examining = false
	PlayerManager.player.CURSOR.visible = true
	should_stay_in_focus = false
	if PlayerManager.EquippedItem == \"Box\":
		_on_interaction_complete()
		PlayerManager.DeskItems.append(self)
		get_parent().visible = false
	else:
		$\"../../PictureFrame4Fade\".play_backwards(\"PictureFrame4Fade\")

func _hide_original_object() -> void:
	# Find and hide all MeshInstance3D children (including nested)
	_hide_meshes_in_children(self)
	
func _hide_meshes_in_children(node: Node) -> void:
	# Hide if this node is a MeshInstance3D (but not our debug mesh)
	if node is MeshInstance3D and node.name != \"DebugMesh\":
		node.visible = false
	
	# Recursively hide in children
	for child in node.get_children():
		_hide_meshes_in_children(child)

func _show_original_object() -> void:
	# Find and show all MeshInstance3D children (including nested)
	_show_meshes_in_children(self)
	
func _show_meshes_in_children(node: Node) -> void:
	# Show if this node is a MeshInstance3D (but not our debug mesh)
	if node is MeshInstance3D and node.name != \"DebugMesh\":
		node.visible = true
	
	# Recursively show in children
	for child in node.get_children():
		_show_meshes_in_children(child)
	

func _return_to_original() -> void:
	
	# Create new tween for return animation
	tween = create_tween()
	tween.set_parallel(true)
	
	# Animate debug mesh back to original position, rotation and scale
	tween.tween_property(debug_mesh, \"global_position\", original_position, 1.0).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_CUBIC)
	tween.tween_property(debug_mesh, \"global_rotation\", original_rotation, 1.0).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_CUBIC)
	tween.tween_property(debug_mesh, \"scale\", original_scale, 1.0).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_CUBIC)
	
	# Wait for return animation to complete
	await tween.finished
	
	# Hide debug mesh and show original object
	debug_mesh.visible = false
	_show_original_object()  # This is where the original object becomes visible again
	
	# Re-enable collision
	if has_node(\"CollisionShape3D\"):
		$CollisionShape3D.disabled = false

# Function to rotate the debug mesh left (counter-clockwise)
func rotate_right() -> void:
	if not is_in_interaction or not debug_mesh.visible:
		return
	
	current_rotation += rotation_speed * get_process_delta_time()
	_apply_rotation()

# Function to rotate the debug mesh right (clockwise)
func rotate_left() -> void:
	if not is_in_interaction or not debug_mesh.visible:
		return
	
	current_rotation -= rotation_speed * get_process_delta_time()
	_apply_rotation()

# Apply the current rotation to the debug mesh
func _apply_rotation() -> void:
	if debug_mesh and debug_mesh.visible:
		# Get the current rotation and apply the Y rotation
		var current_rot = debug_mesh.global_rotation
		debug_mesh.global_rotation = Vector3(current_rot.x, current_rotation, current_rot.z)
"

[sub_resource type="ConvexPolygonShape3D" id="ConvexPolygonShape3D_kecfy"]
points = PackedVector3Array(0.303867, -0.000323, -0.117992, -0.71904, -0.000107301, -0.159781, -0.915132, 0.000755496, -0.504346, 0.291798, 0.0430326, -1.24039, 0.415475, 0.0307377, -0.117992, 0.303867, -0.000323, 0.184785, 0.291798, 0.0430326, 1.29616, 0.0367155, 0.955009, 1.34, -0.0400398, 1.22916, 1.34, -0.294987, 2.14136, 1.29616, -0.859939, 0.369386, -0.639711, 0.0367155, 0.955009, -1.27911, 0.403405, 0.0740933, -1.24039, 0.470261, 0.109899, -0.117992, 0.415475, 0.0307377, 0.184785, 0.403405, 0.0740933, 1.29616, 0.148458, 0.986286, 1.34, 0.0717029, 1.26044, 1.34, -0.183244, 2.17263, 1.29616, -0.30353, 2.17198, 0.18299, -0.30353, 2.17198, -0.116197, -0.294987, 2.14136, -1.24039, -0.0400398, 1.22916, -1.27911, 0.148458, 0.986286, -1.27911, 0.219654, 1.00613, -1.19681, 0.458056, 0.153255, -1.16041, 0.407067, 0.336168, -1.16041, 0.470261, 0.109899, 0.184785, 0.458056, 0.153255, 1.21643, 0.219654, 1.00613, 1.25745, 0.142898, 1.28028, 1.25745, -0.191788, 2.20326, 0.18299, -0.0955044, 2.13316, 1.21643, -0.104048, 2.16379, 0.18299, -0.191788, 2.20326, -0.116197, -0.183244, 2.17263, -1.24039, 0.0717029, 1.26044, -1.27911, 0.142898, 1.28028, -1.19681, -0.0955044, 2.13316, -1.16041, -0.104048, 2.16379, -0.116197, 0.407067, 0.336168, 1.21643)

[sub_resource type="Animation" id="Animation_f4emo"]
resource_name = "PictureFrame4Fade"
length = 0.1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("PictureFrame4:transparency")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.1),
"transitions": PackedFloat32Array(1, 1),
"update": 0,
"values": [0.0, 1.0]
}

[sub_resource type="Animation" id="Animation_58w47"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("PictureFrame4:transparency")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [0.0]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_u541n"]
_data = {
"PictureFrame4Fade": SubResource("Animation_f4emo"),
"RESET": SubResource("Animation_58w47")
}

[node name="Picture Frame" type="Node3D"]

[node name="PictureFrame4" type="MeshInstance3D" parent="."]
material_override = ExtResource("1_6bnvm")
mesh = ExtResource("4_nos2b")

[node name="PictureFrame4" type="StaticBody3D" parent="PictureFrame4" node_paths=PackedStringArray("mesh")]
script = SubResource("GDScript_f5sxg")
target_mesh = ExtResource("4_nos2b")
target_material = ExtResource("1_6bnvm")
outline_material = ExtResource("4_busgw")
mesh = NodePath("..")
has_outline = true

[node name="CollisionShape3D" type="CollisionShape3D" parent="PictureFrame4/PictureFrame4"]
shape = SubResource("ConvexPolygonShape3D_kecfy")

[node name="PictureFrame4Fade" type="AnimationPlayer" parent="."]
libraries = {
"": SubResource("AnimationLibrary_u541n")
}

[connection signal="interacted" from="PictureFrame4/PictureFrame4" to="PictureFrame4/PictureFrame4" method="_on_interacted"]
